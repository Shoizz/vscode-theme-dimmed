<!DOCTYPE html>
<html lang="en">
<head>

<script>
    // Just a lil’ script to show off that inline JS gets highlighted
    window.console && console.log('foo');
    var x = 2;
    var _self = (typeof window !== 'undefined')
    ? window   // if in browser
    : (
        (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope)
        ? self // if in worker
        : {}   // if in node js
    );
    var Prism = (function(){

      // Private helper vars
      var lang = /\blang(?:uage)?-(\w+)\b/i;
      var uniqueId = 0;

      var _ = _self.Prism = {
      manual: _self.Prism && _self.Prism.manual,
      util: {
          encode: function (tokens) {
              if (tokens instanceof Token) {
                  return new Token(tokens.type, _.util.encode(tokens.content), tokens.alias);
              } else if (_.util.type(tokens) === 'Array') {
                  return tokens.map(_.util.encode);
              } else {
                  return tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\u00a0/g, ' ');
              }
          },

          type: function (o) {
              return Object.prototype.toString.call(o).match(/\[object (\w+)\]/)[1];
          },

          objId: function (obj) {
              if (!obj['__id']) {
                  Object.defineProperty(obj, '__id', { value: ++uniqueId });
              }
              return obj['__id'];
          },

          // Deep clone a language definition (e.g. to extend it)
          clone: function (o) {
              var type = _.util.type(o);

              switch (type) {
                  case 'Object':
                      var clone = {};

                      for (var key in o) {
                          if (o.hasOwnProperty(key)) {
                              clone[key] = _.util.clone(o[key]);
                          }
                      }

                      return clone;

                  case 'Array':
                      return o.map(function(v) { return _.util.clone(v); });
              }

              return o;
          }
      },

      languages: {
          extend: function (id, redef) {
              var lang = _.util.clone(_.languages[id]);

              for (var key in redef) {
                  lang[key] = redef[key];
              }

              return lang;
          },

          /**
           * Insert a token before another token in a language literal
           * As this needs to recreate the object (we cannot actually insert before keys in object literals),
           * we cannot just provide an object, we need anobject and a key.
           * @param inside The key (or language id) of the parent
           * @param before The key to insert before. If not provided, the function appends instead.
           * @param insert Object with the key/value pairs to insert
           * @param root The object that contains `inside`. If equal to Prism.languages, it can be omitted.
           */
          insertBefore: function (inside, before, insert, root) {
              root = root || _.languages;
              var grammar = root[inside];

              if (arguments.length == 2) {
                  insert = arguments[1];

                  for (var newToken in insert) {
                      if (insert.hasOwnProperty(newToken)) {
                          grammar[newToken] = insert[newToken];
                      }
                  }

                  return grammar;
              }

              var ret = {};

              for (var token in grammar) {

                  if (grammar.hasOwnProperty(token)) {

                      if (token == before) {

                          for (var newToken in insert) {

                              if (insert.hasOwnProperty(newToken)) {
                                  ret[newToken] = insert[newToken];
                              }
                          }
                      }

                      ret[token] = grammar[token];
                  }
              }

              // Update references in other language definitions
              _.languages.DFS(_.languages, function(key, value) {
                  if (value === root[inside] && key != inside) {
                      this[key] = ret;
                  }
              });

              return root[inside] = ret;
          },

          // Traverse a language definition with Depth First Search
          DFS: function(o, callback, type, visited) {
              visited = visited || {};
              for (var i in o) {
                  if (o.hasOwnProperty(i)) {
                      callback.call(o, i, o[i], type || i);

                      if (_.util.type(o[i]) === 'Object' && !visited[_.util.objId(o[i])]) {
                          visited[_.util.objId(o[i])] = true;
                          _.languages.DFS(o[i], callback, null, visited);
                      }
                      else if (_.util.type(o[i]) === 'Array' && !visited[_.util.objId(o[i])]) {
                          visited[_.util.objId(o[i])] = true;
                          _.languages.DFS(o[i], callback, i, visited);
                      }
                  }
              }
          }
      },
      plugins: {},

      highlightAll: function(async, callback) {
          var env = {
              callback: callback,
              selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
          };

          _.hooks.run("before-highlightall", env);

          var elements = env.elements || document.querySelectorAll(env.selector);

          for (var i=0, element; element = elements[i++];) {
              _.highlightElement(element, async === true, env.callback);
          }
      },

      highlightElement: function(element, async, callback) {
          // Find language
          var language, grammar, parent = element;

          while (parent && !lang.test(parent.className)) {
              parent = parent.parentNode;
          }

          if (parent) {
              language = (parent.className.match(lang) || [,''])[1].toLowerCase();
              grammar = _.languages[language];
          }

          // Set language on the element, if not present
          element.className = element.className.replace(lang, '').replace(/\s+/g, ' ') + ' language-' + language;

          // Set language on the parent, for styling
          parent = element.parentNode;

          if (/pre/i.test(parent.nodeName)) {
              parent.className = parent.className.replace(lang, '').replace(/\s+/g, ' ') + ' language-' + language;
          }

          var code = element.textContent;

          var env = {
              element: element,
              language: language,
              grammar: grammar,
              code: code
          };

          _.hooks.run('before-sanity-check', env);

          if (!env.code || !env.grammar) {
              if (env.code) {
                  _.hooks.run('before-highlight', env);
                  env.element.textContent = env.code;
                  _.hooks.run('after-highlight', env);
              }
              _.hooks.run('complete', env);
              return;
          }

          _.hooks.run('before-highlight', env);

          if (async && _self.Worker) {
              var worker = new Worker(_.filename);

              worker.onmessage = function(evt) {
                  env.highlightedCode = evt.data;

                  _.hooks.run('before-insert', env);

                  env.element.innerHTML = env.highlightedCode;

                  callback && callback.call(env.element);
                  _.hooks.run('after-highlight', env);
                  _.hooks.run('complete', env);
              };

              worker.postMessage(JSON.stringify({
                  language: env.language,
                  code: env.code,
                  immediateClose: true
              }));
          }
          else {
              env.highlightedCode = _.highlight(env.code, env.grammar, env.language);

              _.hooks.run('before-insert', env);

              env.element.innerHTML = env.highlightedCode;

              callback && callback.call(element);

              _.hooks.run('after-highlight', env);
              _.hooks.run('complete', env);
          }
      },

      highlight: function (text, grammar, language) {
          var tokens = _.tokenize(text, grammar);
          return Token.stringify(_.util.encode(tokens), language);
      },

      matchGrammar: function (text, strarr, grammar, index, startPos, oneshot, target) {
          var Token = _.Token;

          for (var token in grammar) {
              if(!grammar.hasOwnProperty(token) || !grammar[token]) {
                  continue;
              }

              if (token == target) {
                  return;
              }

              var patterns = grammar[token];
              patterns = (_.util.type(patterns) === "Array") ? patterns : [patterns];

              for (var j = 0; j < patterns.length; ++j) {
                  var pattern = patterns[j],
                      inside = pattern.inside,
                      lookbehind = !!pattern.lookbehind,
                      greedy = !!pattern.greedy,
                      lookbehindLength = 0,
                      alias = pattern.alias;

                  if (greedy && !pattern.pattern.global) {
                      // Without the global flag, lastIndex won't work
                      var flags = pattern.pattern.toString().match(/[imuy]*$/)[0];
                      pattern.pattern = RegExp(pattern.pattern.source, flags + "g");
                  }

                  pattern = pattern.pattern || pattern;

                  // Don’t cache length as it changes during the loop
                  for (var i = index, pos = startPos; i < strarr.length; pos += strarr[i].length, ++i) {

                      var str = strarr[i];

                      if (strarr.length > text.length) {
                          // Something went terribly wrong, ABORT, ABORT!
                          return;
                      }

                      if (str instanceof Token) {
                          continue;
                      }

                      pattern.lastIndex = 0;

                      var match = pattern.exec(str),
                          delNum = 1;

                      // Greedy patterns can override/remove up to two previously matched tokens
                      if (!match && greedy && i != strarr.length - 1) {
                          pattern.lastIndex = pos;
                          match = pattern.exec(text);
                          if (!match) {
                              break;
                          }

                          var from = match.index + (lookbehind ? match[1].length : 0),
                              to = match.index + match[0].length,
                              k = i,
                              p = pos;

                          for (var len = strarr.length; k < len && (p < to || (!strarr[k].type && !strarr[k - 1].greedy)); ++k) {
                              p += strarr[k].length;
                              // Move the index i to the element in strarr that is closest to from
                              if (from >= p) {
                                  ++i;
                                  pos = p;
                              }
                          }

                          /*
                           * If strarr[i] is a Token, then the match starts inside another Token, which is invalid
                           * If strarr[k - 1] is greedy we are in conflict with another greedy pattern
                           */
                          if (strarr[i] instanceof Token || strarr[k - 1].greedy) {
                              continue;
                          }

                          // Number of tokens to delete and replace with the new match
                          delNum = k - i;
                          str = text.slice(pos, p);
                          match.index -= pos;
                      }

                      if (!match) {
                          if (oneshot) {
                              break;
                          }

                          continue;
                      }

                      if(lookbehind) {
                          lookbehindLength = match[1].length;
                      }

                      var from = match.index + lookbehindLength,
                          match = match[0].slice(lookbehindLength),
                          to = from + match.length,
                          before = str.slice(0, from),
                          after = str.slice(to);

                      var args = [i, delNum];

                      if (before) {
                          ++i;
                          pos += before.length;
                          args.push(before);
                      }

                      var wrapped = new Token(token, inside? _.tokenize(match, inside) : match, alias, match, greedy);

                      args.push(wrapped);

                      if (after) {
                          args.push(after);
                      }

                      Array.prototype.splice.apply(strarr, args);

                      if (delNum != 1)
                          _.matchGrammar(text, strarr, grammar, i, pos, true, token);

                      if (oneshot)
                          break;
                  }
              }
          }
      },

      tokenize: function(text, grammar, language) {
          var strarr = [text];

          var rest = grammar.rest;

          if (rest) {
              for (var token in rest) {
                  grammar[token] = rest[token];
              }

              delete grammar.rest;
          }

          _.matchGrammar(text, strarr, grammar, 0, 0, false);

          return strarr;
      },

      hooks: {
          all: {},

          add: function (name, callback) {
              var hooks = _.hooks.all;

              hooks[name] = hooks[name] || [];

              hooks[name].push(callback);
          },

          run: function (name, env) {
              var callbacks = _.hooks.all[name];

              if (!callbacks || !callbacks.length) {
                  return;
              }

              for (var i=0, callback; callback = callbacks[i++];) {
                  callback(env);
              }
          }
      }
      };

      var Token = _.Token = function(type, content, alias, matchedStr, greedy) {
      this.type = type;
      this.content = content;
      this.alias = alias;
      // Copy of the full string this token was created from
      this.length = (matchedStr || "").length|0;
      this.greedy = !!greedy;
      };

      Token.stringify = function(o, language, parent) {
      if (typeof o == 'string') {
          return o;
      }

      if (_.util.type(o) === 'Array') {
          return o.map(function(element) {
              return Token.stringify(element, language, o);
          }).join('');
      }

      var env = {
          type: o.type,
          content: Token.stringify(o.content, language, parent),
          tag: 'span',
          classes: ['token', o.type],
          attributes: {},
          language: language,
          parent: parent
      };

      if (env.type == 'comment') {
          env.attributes['spellcheck'] = 'true';
      }

      if (o.alias) {
          var aliases = _.util.type(o.alias) === 'Array' ? o.alias : [o.alias];
          Array.prototype.push.apply(env.classes, aliases);
      }

      _.hooks.run('wrap', env);

      var attributes = Object.keys(env.attributes).map(function(name) {
          return name + '="' + (env.attributes[name] || '').replace(/"/g, '&quot;') + '"';
      }).join(' ');

      return '<' + env.tag + ' class="' + env.classes.join(' ') + '"' + (attributes ? ' ' + attributes : '') + '>' + env.content + '</' + env.tag + '>';

      };

      if (!_self.document) {
      if (!_self.addEventListener) {
          // in Node.js
          return _self.Prism;
      }
       // In worker
      _self.addEventListener('message', function(evt) {
          var message = JSON.parse(evt.data),
              lang = message.language,
              code = message.code,
              immediateClose = message.immediateClose;

          _self.postMessage(_.highlight(code, _.languages[lang], lang));
          if (immediateClose) {
              _self.close();
          }
      }, false);

      return _self.Prism;
      }

      //Get current script and highlight
      var script = document.currentScript || [].slice.call(document.getElementsByTagName("script")).pop();

      if (script) {
      _.filename = script.src;

      if (!_.manual && !script.hasAttribute('data-manual')) {
          if(document.readyState !== "loading") {
              if (window.requestAnimationFrame) {
                  window.requestAnimationFrame(_.highlightAll);
              } else {
                  window.setTimeout(_.highlightAll, 16);
              }
          }
          else {
              document.addEventListener('DOMContentLoaded', _.highlightAll);
          }
      }
      }

      return _self.Prism;

      })();

      if (typeof module !== 'undefined' && module.exports) {
      module.exports = Prism;
      }

      // hack for components to work correctly in node.js
      if (typeof global !== 'undefined') {
      global.Prism = Prism;
      }


      /* **********************************************
       Begin prism-markup.js
      ********************************************** */

      Prism.languages.markup = {
      'comment': /<!--[\s\S]*?-->/,
      'prolog': /<\?[\s\S]+?\?>/,
      'doctype': /<!DOCTYPE[\s\S]+?>/i,
      'cdata': /<!\[CDATA\[[\s\S]*?]]>/i,
      'tag': {
          pattern: /<\/?(?!\d)[^\s>\/=$<]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\\1|\\?(?!\1)[\s\S])*\1|[^\s'">=]+))?)*\s*\/?>/i,
          inside: {
              'tag': {
                  pattern: /^<\/?[^\s>\/]+/i,
                  inside: {
                      'punctuation': /^<\/?/,
                      'namespace': /^[^\s>\/:]+:/
                  }
              },
              'attr-value': {
                  pattern: /=(?:('|")[\s\S]*?(\1)|[^\s>]+)/i,
                  inside: {
                      'punctuation': /[=>"']/
                  }
              },
              'punctuation': /\/?>/,
              'attr-name': {
                  pattern: /[^\s>\/]+/,
                  inside: {
                      'namespace': /^[^\s>\/:]+:/
                  }
              }

          }
      },
      'entity': /&#?[\da-z]{1,8};/i
      };

      Prism.languages.markup['tag'].inside['attr-value'].inside['entity'] =
      Prism.languages.markup['entity'];

      // Plugin to make entity title show the real entity, idea by Roman Komarov
      Prism.hooks.add('wrap', function(env) {

      if (env.type === 'entity') {
          env.attributes['title'] = env.content.replace(/&amp;/, '&');
      }
      });

      Prism.languages.xml = Prism.languages.markup;
      Prism.languages.html = Prism.languages.markup;
      Prism.languages.mathml = Prism.languages.markup;
      Prism.languages.svg = Prism.languages.markup;


      /* **********************************************
       Begin prism-css.js
      ********************************************** */

      Prism.languages.css = {
      'comment': /\/\*[\s\S]*?\*\//,
      'atrule': {
          pattern: /@[\w-]+?.*?(;|(?=\s*\{))/i,
          inside: {
              'rule': /@[\w-]+/
              // See rest below
          }
      },
      'url': /url\((?:(["'])(\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1|.*?)\)/i,
      'selector': /[^\{\}\s][^\{\};]*?(?=\s*\{)/,
      'string': {
          pattern: /("|')(\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
          greedy: true
      },
      'property': /(\b|\B)[\w-]+(?=\s*:)/i,
      'important': /\B!important\b/i,
      'function': /[-a-z0-9]+(?=\()/i,
      'punctuation': /[(){};:]/
      };

      Prism.languages.css['atrule'].inside.rest = Prism.util.clone(Prism.languages.css);

      if (Prism.languages.markup) {
      Prism.languages.insertBefore('markup', 'tag', {
          'style': {
              pattern: /(<style[\s\S]*?>)[\s\S]*?(?=<\/style>)/i,
              lookbehind: true,
              inside: Prism.languages.css,
              alias: 'language-css'
          }
      });

      Prism.languages.insertBefore('inside', 'attr-value', {
          'style-attr': {
              pattern: /\s*style=("|').*?\1/i,
              inside: {
                  'attr-name': {
                      pattern: /^\s*style/i,
                      inside: Prism.languages.markup.tag.inside
                  },
                  'punctuation': /^\s*=\s*['"]|['"]\s*$/,
                  'attr-value': {
                      pattern: /.+/i,
                      inside: Prism.languages.css
                  }
              },
              alias: 'language-css'
          }
      }, Prism.languages.markup.tag);
      }

      /* **********************************************
       Begin prism-clike.js
      ********************************************** */

      Prism.languages.clike = {
      'comment': [
          {
              pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
              lookbehind: true
          },
          {
              pattern: /(^|[^\\:])\/\/.*/,
              lookbehind: true
          }
      ],
      'string': {
          pattern: /(["'])(\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
          greedy: true
      },
      'class-name': {
          pattern: /((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[a-z0-9_\.\\]+/i,
          lookbehind: true,
          inside: {
              punctuation: /(\.|\\)/
          }
      },
      'keyword': /\b(if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,
      'boolean': /\b(true|false)\b/,
      'function': /[a-z0-9_]+(?=\()/i,
      'number': /\b-?(?:0x[\da-f]+|\d*\.?\d+(?:e[+-]?\d+)?)\b/i,
      'operator': /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/,
      'punctuation': /[{}[\];(),.:]/
      };


      /* **********************************************
       Begin prism-javascript.js
      ********************************************** */

      Prism.languages.javascript = Prism.languages.extend('clike', {
      'keyword': /\b(as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|var|void|while|with|yield)\b/,
      'number': /\b-?(0[xX][\dA-Fa-f]+|0[bB][01]+|0[oO][0-7]+|\d*\.?\d+([Ee][+-]?\d+)?|NaN|Infinity)\b/,
      // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
      'function': /[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*(?=\()/i,
      'operator': /-[-=]?|\+[+=]?|!=?=?|<<?=?|>>?>?=?|=(?:==?|>)?|&[&=]?|\|[|=]?|\*\*?=?|\/=?|~|\^=?|%=?|\?|\.{3}/
      });

      Prism.languages.insertBefore('javascript', 'keyword', {
      'regex': {
          pattern: /(^|[^/])\/(?!\/)(\[[^\]\r\n]+]|\\.|[^/\\\[\r\n])+\/[gimyu]{0,5}(?=\s*($|[\r\n,.;})]))/,
          lookbehind: true,
          greedy: true
      }
      });

      Prism.languages.insertBefore('javascript', 'string', {
      'template-string': {
          pattern: /`(?:\\\\|\\?[^\\])*?`/,
          greedy: true,
          inside: {
              'interpolation': {
                  pattern: /\$\{[^}]+\}/,
                  inside: {
                      'interpolation-punctuation': {
                          pattern: /^\$\{|\}$/,
                          alias: 'punctuation'
                      },
                      rest: Prism.languages.javascript
                  }
              },
              'string': /[\s\S]+/
          }
      }
      });

      if (Prism.languages.markup) {
      Prism.languages.insertBefore('markup', 'tag', {
          'script': {
              pattern: /(<script[\s\S]*?>)[\s\S]*?(?=<\/script>)/i,
              lookbehind: true,
              inside: Prism.languages.javascript,
              alias: 'language-javascript'
          }
      });
      }

      Prism.languages.js = Prism.languages.javascript;


      /* **********************************************
       Begin prism-file-highlight.js
      ********************************************** */

      (function () {
      if (typeof self === 'undefined' || !self.Prism || !self.document || !document.querySelector) {
          return;
      }

      self.Prism.fileHighlight = function() {

          var Extensions = {
              'js': 'javascript',
              'py': 'python',
              'rb': 'ruby',
              'ps1': 'powershell',
              'psm1': 'powershell',
              'sh': 'bash',
              'bat': 'batch',
              'h': 'c',
              'tex': 'latex'
          };

          Array.prototype.slice.call(document.querySelectorAll('pre[data-src]')).forEach(function (pre) {
              var src = pre.getAttribute('data-src');

              var language, parent = pre;
              var lang = /\blang(?:uage)?-(?!\*)(\w+)\b/i;
              while (parent && !lang.test(parent.className)) {
                  parent = parent.parentNode;
              }

              if (parent) {
                  language = (pre.className.match(lang) || [, ''])[1];
              }

              if (!language) {
                  var extension = (src.match(/\.(\w+)$/) || [, ''])[1];
                  language = Extensions[extension] || extension;
              }

              var code = document.createElement('code');
              code.className = 'language-' + language;

              pre.textContent = '';

              code.textContent = 'Loading…';

              pre.appendChild(code);

              var xhr = new XMLHttpRequest();

              xhr.open('GET', src, true);

              xhr.onreadystatechange = function () {
                  if (xhr.readyState == 4) {

                      if (xhr.status < 400 && xhr.responseText) {
                          code.textContent = xhr.responseText;

                          Prism.highlightElement(code);
                      }
                      else if (xhr.status >= 400) {
                          code.textContent = '✖ Error ' + xhr.status + ' while fetching file: ' + xhr.statusText;
                      }
                      else {
                          code.textContent = '✖ Error: File does not exist or is empty';
                      }
                  }
              };

              xhr.send(null);
          });

      };

      document.addEventListener('DOMContentLoaded', self.Prism.fileHighlight);

      })();
</script>
<meta charset="utf-8" />
<link rel="shortcut icon" href="favicon.png" />
<title>Prism</title>
<link rel="stylesheet" href="style.css" />
<link rel="stylesheet" href="themes/prism.css" data-noprefix />
<script src = "prefixfree.min.js"></script>

<script>var _gaq = [['_setAccount', 'UA-33746269-1'], ['_trackPageview']];</script>
<script src = "https://www.google-analytics.com/ga.js" async></script>
</head>
<body>

<header>
    <div class="intro" data-src="templates/header-main.html" data-type="text/html"></div>

    <ul id="features">
        <li>
            <strong>Dead simple</strong>
            Include prism.css and prism.js, use proper HTML5 code tags (<code>code.language-xxxx</code>), done!
        </li>
        <li>
            <strong>Intuitive</strong>
            Language classes are inherited so you can only define the language once for multiple code snippets.
        </li>
        <li>
            <strong>Light as a feather</strong>
            The core is 2KB minified &amp; gzipped. Languages add 0.3-0.5KB each, themes are around 1KB.
        </li>
        <li>
            <strong>Blazing fast</strong>
            Supports parallelism with Web Workers, if available.
        </li>
        <li>
            <strong>Extensible</strong>
            Define new languages or extend existing ones.
            Add new features thanks to Prism’s plugin architecture.
        </li>
        <li>
            <strong>Easy styling</strong>
            All styling is done through CSS, with sensible class names like <code>.comment</code>, <code>.string</code>, <code>.property</code> etc
        </li>
    </ul>

</header>

<section id="used-by">
    <h1>Used By</h1>

    <p>Prism is used on several websites, small and large. Some of them are:</p>

    <div class="used-by-logos">
        <a href="http://smashingmagazine.com" target="_blank"><img src="img/logo-smashing.png" alt="Smashing Magazine" /></a>
        <a class="uswds" href="https://playbook.cio.gov/designstandards/" target="_blank">U.S. Web Design Standards</a>
        <a href="http://alistapart.com" target="_blank"><img src="img/logo-ala.png" alt="A List Apart" /></a>

        <a href="https://developer.mozilla.org/" target="_blank"><img src="img/logo-mdn.png" alt="Mozilla Developer Network (MDN)" /></a>
        <a href="http://css-tricks.com" target="_blank"><img src="img/logo-css-tricks.png" alt="CSS-Tricks" /></a>
        <a href="http://www.sitepoint.com" target="_blank"><img src="img/logo-sitepoint.png" alt="SitePoint" /></a>
        <a href="https://www.drupal.org" target="_blank"><img src="img/logo-drupal.png" alt="Drupal" /></a>
    </div>

    <p>It’s also used on <a href="https://brendaneich.com/2012/10/harmony-of-dreams-come-true/" target="_blank">the personal blog of Brendan Eich</a>, creator of JavaScript itself!</p>
</section>

<section id="examples">
    <h1>Examples</h1>

    <p>The Prism source, highlighted with Prism (don’t you just love how meta this is?):</p>
    <pre data-src="prism.js"></pre>

    <p>This page’s CSS code, highlighted with Prism:</p>
    <pre data-src="style.css"></pre>

    <p>This page’s HTML, highlighted with Prism:</p>
    <pre data-src="index.html"></pre>

    <p>This page’s logo (SVG), highlighted with Prism:</p>
    <pre data-src="logo.svg"></pre>

    <p>If you’re still not sold, you can <a href="examples.html">view more examples</a> or <a href="test.html">try it out for yourself</a>.</p>
</section>

<section id="features-full" class="language-markup">
    <h1>Full list of features</h1>
    <ul>
        <li><strong>Only 2KB</strong> minified &amp; gzipped (core). Each language definition adds roughly 300-500 bytes.</li>
        <li>Encourages good author practices. Other highlighters encourage or even force you to use elements that are semantically wrong,
            like <code>&lt;pre></code> (on its own) or <code>&lt;script></code>.
            Prism forces you to use the correct element for marking up code: <code>&lt;code></code>.
            On its own for inline code, or inside a &lt;pre> for blocks of code.
            In addition, the language is defined through the way recommended in the HTML5 draft: through a language-xxxx class.</li>
        <li>The language definition is inherited. This means that if multiple code snippets have the same language, you can just define it once, in one of their common ancestors.</li>
        <li>Supports <strong>parallelism with Web Workers</strong>, if available. Disabled by default (<a href="faq.html#why-is-asynchronous-highlighting-disabled-by-default">why?</a>).</li>
        <li>Very easy to extend without modifying the code, due to Prism’s <a href="#plugins">plugin architecture</a>. Multiple hooks are scattered throughout the source.</li>
        <li>Very easy to <a href="extending.html#language-definitions">define new languages</a>. Only thing you need is a good understanding of regular expressions</li>
        <li>All styling is done through CSS, with <a href="faq.html#how-do-i-know-which-tokens-i-can-style-for">sensible class names</a> rather than ugly namespaced abbreviated nonsense.</li>
        <li>Wide browser support: IE9+, Firefox, Chrome, Safari, <a href="faq.html#this-page-doesnt-work-in-opera">Opera</a>, most Mobile browsers</li>
        <li>Highlights embedded languages (e.g. CSS inside HTML, JavaScript inside HTML)</li>
        <li>Highlights inline code as well, not just code blocks</li>
        <li>Highlights nested languages (CSS in HTML, JavaScript in HTML)</li>
        <li>It doesn’t force you to use any Prism-specific markup, not even a Prism-specific class name, only standard markup you should be using anyway. So, you can just try it for a while, remove it if you don’t like it and leave no traces behind.</li>
        <li>Highlight specific lines and/or line ranges (requires <a href="plugins/line-highlight/">plugin</a>)</li>
        <li>Show invisible characters like tabs, line breaks etc (requires <a href="plugins/show-invisibles/">plugin</a>)</li>
        <li>Autolink URLs and emails, use Markdown links in comments (requires <a href="plugins/autolinker/">plugin</a>)</li>
    </ul>
</section>

<section id="limitations">
    <h1>Limitations</h1>
    <ul>
        <li>Any pre-existing HTML in the code will be stripped off. <a href="faq.html#if-pre-existing-html-is-stripped-off-how-can-i-highlight">There are ways around it though</a>.</li>
        <li>Regex-based so it *will* fail on <a href="examples.html#failures">certain edge cases</a>.</li>
        <li>No IE 6-8 support. If someone can read code, they are probably in the 85% of the population with a modern browser.</li>
    </ul>
</section>

<section id="basic-usage" class="language-markup">
    <h1>Basic usage</h1>

    <p>You will need to include the <code>prism.css</code> and <code>prism.js</code> files you downloaded in your page. Example:
    <pre><code>&lt;!DOCTYPE html>
&lt;html>
&lt;head>
    ...</code>
    <code class="highlight">&lt;link href="themes/prism.css" rel="stylesheet" /></code>
<code>&lt;/head>
&lt;body>
    ...</code>
    <code class="highlight">&lt;script src="prism.js">&lt;/script></code>
<code>&lt;/body>
&lt;/html></code></pre>

    <p>Prism does its best to encourage good authoring practices. Therefore, it only works with <code>&lt;code></code> elements, since marking up code without a <code>&lt;code></code> element is semantically invalid.
    <a href="http://www.w3.org/TR/html5/text-level-semantics.html#the-code-element">According to the HTML5 spec</a>, the recommended way to define a code language is a <code>language-xxxx</code> class, which is what Prism uses.
    To make things easier however, Prism assumes that this language definition is inherited. Therefore, if multiple <code>&lt;code></code> elements have the same language, you can add the <code>language-xxxx</code> class on one of their common ancestors.
    This way, you can also define a document-wide default language, by adding a <code>language-xxxx</code> class on the <code>&lt;body></code> or <code>&lt;html></code> element.

    <p>If you want to opt-out of highlighting for a <code>&lt;code></code> element that is a descendant of an element with a declared code language, you can add the class <code>language-none</code> to it (or any non-existing language, really).</p>

    <p>The <a href="https://www.w3.org/TR/html5/grouping-content.html#the-pre-element">recommended way to mark up a code block</a>
    (both for semantics and for Prism) is a <code>&lt;pre></code> element with a <code>&lt;code></code> element inside, like so:</p>
    <pre><code>&lt;pre>&lt;code class="language-css">p { color: red }&lt;/code>&lt;/pre></code></pre>
    <p>If you use that pattern, the <code>&lt;pre></code> will automatically get the <code>language-xxxx</code> class (if it doesn’t already have it) and will be styled as a code block.</p>

    <p>If you want to prevent any elements from being automatically highlighted, you can use the attribute <code>data-manual</code> on the <code>&lt;script></code> element you used for prism and use the <a href="extending.html#api">API</a>.
    Example:</p>
    <pre><code>&lt;script src="prism.js" data-manual>&lt;/script></code></pre>

    <p>If you want to use Prism on the server or through the command line, Prism can be used with Node.js as well.
    This might be useful if you're trying to generate static HTML pages with highlighted code for environments that don't support browser-side JS, like <a href="https://www.ampproject.org/">AMP pages</a>.</p>

    <p>You can install Prism for Node.js by running:</p>
    <pre><code>$ npm install prismjs</code></pre>

    <p>Example:</p>
    <pre><code class="language-js">var Prism = require('prismjs');

// The code snippet you want to highlight, as a string
var code = "var data = 1;";

// Returns a highlighted HTML string
var html = Prism.highlight(code, Prism.languages.javascript);</code></pre>
</section>

<section id="languages-list" class="language-markup">
    <h1>Supported languages</h1>
    <p>This is the list of all <span id="languages-list-count"></span> languages currently supported by Prism, with their corresponding alias, to use in place of <code>xxxx</code> in the <code>language-xxxx</code> class:</p>
</section>

<section id="plugins">
    <h1>Plugins</h1>
    <p>Plugins are additional scripts (and CSS code) that extend Prism’s functionality. Many of the following plugins are official, but are released as plugins to keep the Prism Core small for those who don’t need the extra functionality.</p>
    <ul class="plugin-list"></ul>

    <p>No assembly required to use them. Just select them in the <a href="download.html">download</a> page.</p>
    <p>It’s very easy to <a href="extending.html#writing-plugins">write your own Prism plugins</a>. Did you write a plugin for Prism that you want added to this list? <a href="https://github.com/LeaVerou/prism" target="_blank">Send a pull request</a>!</p>
</section>

<section id="languages">
    <h1>Third-party language definitions</h1>

    <ul>
        <li><a href="https://github.com/SassDoc/prism-scss-sassdoc">SassDoc Sass/Scss comments</a></li>
    </ul>
</section>

<section id="tutorials">
    <h1>Third-party tutorials</h1>

    <p>Several tutorials have been written by members of the community to help you integrate Prism into multiple different website types and configurations:</p>

    <ul>
        <li><a href="https://websitebeaver.com/escape-html-inside-code-or-pre-tag-to-entities-to-display-raw-code-with-prismjs">Escape HTML Inside &lt;code&gt; or &lt;pre&gt; Tag to Entities to Display Raw Code with PrismJS</a></li>
        <li><a href="http://crambler.com/how-to-implement-prism-js-syntax-highlighting-into-your-wordpress-site/">How To Implement Prism.js Syntax Highlighting Into Your WordPress Site</a></li>
        <li><a href="http://wp.tutsplus.com/tutorials/plugins/adding-a-syntax-highlighter-shortcode-using-prism-js/">Adding a Syntax Highlighter Shortcode Using Prism.js | WPTuts+</a></li>
        <li><a href="http://www.stramaxon.com/2012/07/prism-syntax-highlighter-for-blogger.html">Implement PrismJs Syntax Highlighting to your Blogger/BlogSpot</a></li>
        <li><a href="http://www.allblogtools.com/tricks-and-hacks/beautify-source-codes-in-your-posts-with-prism-syntax-highlighter-for-blogger/">Beautify Source Codes In Your Posts With Prism Syntax Highlighter For Blogger</a></li>
        <li><a href="http://dotnordic.se/extending-and-customizing-prism-syntax-highlighter/">Extending and customizing Prism syntax highlighter</a></li>
        <li><a href="http://schier.co/blog/2013/01/07/how-to-re-run-prismjs-on-ajax-content.html">How To Re-Run Prism.js On AJAX Content</a></li>
        <li><a href="http://www.semisedlak.com/article/highlight-your-code-syntax-with-prismjs/">Highlight your code syntax with Prism.js</a></li>
        <li><a href="http://gmurphey.com/2012/08/09/jekyll-plugin-syntax-highlighting-with-prism.html">Jekyll Plugin: Syntax Highlighting With Prism</a></li>
        <li><a href="http://byverdu.es/2013/06/tutorial-sobre-prism-js-inserta-ejemplos-de-codigo-en-web-wordpress-y-blogger/">[Spanish] Tutorial sobre Prism.js Como utilizarlo en Web, Wordpress y Blogger</a></li>
        <li><a href="https://usetypo3.com/fs-code-snippet.html">A code snippet content element powered by Prism.js for TYPO3 CMS</a></li>
    </ul>

    <p>Please note that the tutorials listed here are not verified to contain correct information. Read at your risk and always check the official documentation here if something doesn’t work :)</p>

    <p>Have you written a tutorial about Prism that’s not already included here? Send a pull request!</p>
</section>

<section id="credits">
    <h1>Credits</h1>
    <ul>
        <li>Special thanks to <a href="https://github.com/Golmote">Golmote</a> and <a href="https://github.com/apfelbox">Jannik Zschiesche</a> for their contributions and for being <strong>amazing maintainers</strong>. Prism would not have been able to keep up without their help.</li>
        <li>To <a href="https://twitter.com/kizmarh">Roman Komarov</a> for his contributions, feedback and testing.</li>
        <li>To <a href="https://twitter.com/zdfs">Zachary Forrest</a> for <a href="https://twitter.com/zdfs/statuses/217834980871639041">coming up with the name “Prism”</a></li>
        <li>To <a href="http://stellarr.deviantart.com/">stellarr</a> for the <a href="http://stellarr.deviantart.com/art/Spectra-Wallpaper-Pack-97785901?q=gallery%3Astellarr%2F185512&qo=2">spectrum background</a> used on this page</li>
        <li>To <a href="https://twitter.com/thecodezombie">Jason Hobbs</a> for <a href="https://twitter.com/thecodezombie/status/217663703825399809">encouraging me</a> to release this script as standalone</li>
    </ul>
</section>

<footer data-src="templates/footer.html" data-type="text/html"></footer>

<script src = "prism.js"></script>
<script src = "utopia.js"></script>
<script src = "components.js"></script>
<script src = "code.js"></script>
<script>
(function() {
    var languageItems = [];
    var languages = components.languages;
    var count = 0;
    for (var id in languages) {
        if (id == 'meta') {
            continue;
        }
        count++;
        var name = languages[id].title || languages[id];

        languageItems.push({
            tag: 'li',
            attributes: {
                'data-id': id
            },
            contents: [
                name,
                ' - ',
                {
                    tag: 'code',
                    contents: id
                }
            ]
        });
    }
    $u.element.create('ul', {
        contents: languageItems,
        inside: '#languages-list'
    });
    $u.element.contents($('#languages-list-count'), count);
}());
</script>

</body>
</html>